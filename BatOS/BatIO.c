/*
 * BatIO.C
 * Модуль ввода вывода

Реализует процедуры используемые осью для ввода вывода.
Процедуры являются многоразовыми и портируемы( Уровни выше этого в дереве структуры
(см. Блоксхему структуры) переписывать не нужно на другой платформе) 
Изменяются только файлы драйверов, и платформозависимые процедуры.

Драйвера пишутся с условием использования именно этой системы
Т.Е. с учетом использования очереди
 * Created: 15.01.2022 13:32:53
 *  Author: dima
 */ 
#include "BatIO.h"
//#include "BatSPI.h"
#include "BatTWI.h"	
#include <avr/io.h> //Описание всех регистров и портов контроллера
//#include <stdarg.h> //макросы для работы с переменным числом параметров
//передаваемых в функцию.

#define TrMasByte 0 //[0]   передача массива байт
#define SetLine	  1 //[1]   позиционирование строки
#define SetColomn 2 //[2]   позиционирование столбца
#define PrintChar 3 //[3]   вывод одного символа
#define SSDInit   4 //[4]   процедура постановки в очередь отправки массива байт инициализации экрана
#define CleanSSD  5 //[5]   процедура очистки экрана
#define OutPMem   6 //[6]	процедура вывода байта из памяти программ
//#define 


//Нужно ли ограничивать область видимости для данных и процедур?
char QueueProc[100]; // максимальная длинна очереди 100
unsigned char DataQueue[200]; // максимальная длинна массива с данными для процедур.

unsigned char MasPosYk[40];  //Выделил 40 байт в оперативе для хранения
//Данных позиционирования указателя
unsigned char CountMasWr=0; //Текущая позиция для записи в массив позиционирования
//миссив с номерами процедур
char PoinProc=0; //Указатель на массив текущей ПРОЦЕДУРЫ для записи
char PoinProcRed=0; // указатель на массив текущей процедуры для чтения
unsigned char PoinQue=0;  //Указатель на МАССИВ ДАННЫХ процедур для записи
unsigned char PoinQueRed=0; //Указатель на массив данных для чтения

extern const char Point[]; // так можно?

//Какие процедуры по вводу выводу нужны оси?
//1. Вывод символа (ПОСИМВОЛЬНЫЙ ВЫВОД)(Может в будущем добавить векторные шрифты?)
//2. Вывод cтроки
//3. Очистка экрана
//4. Инициализация экрана(Стартовая инициализация любых устройств)
//5. Ввод информации с энкодера.

//СЮДА ПЕРЕДАЕТСЯ ПРОСТО СТРОКА ИЛИ СИМВОЛ или цифра дальше все само.
//Процедура использует переменное число параметров(ВНИМАНИЕ не проверяет их корректность)
//Процедура форматированного выводы
//Вывод символа, Вывод цифры, вывод строки
char BPrintf(char Mod, char *MasOut, char Str, char Col){
	QueuingLine(Str);//в очередь позиционирование строки
	QueuingColon(Col);// поставить в очередь позиционирование столбца
		 // Процедура постановки в очередь вывода массива.
	if(Mod=='s'){ 
		QueuingStr(MasOut); // вывод строки 
		return 1; //1 значит успешно
	}
	if(Mod=='c'){//Вывод символа. В случае вывода одного символа сохраняет код символа в массиве данных процедур
		//DataQueue
		QueuingSym((char)MasOut); //проверить что я тут напреобразовывался))
		return 1; //1 значит успешно
	}
	if(Mod=='p'){//вывод указателя
		QueuingOutPM(Point); // адрес массива
		return 1;
	}
	//Окончание блока вывода символа
	//if(ReadSym=='d'){//вывод числа
		//получение цифр числа и постановка очереди вывода символов.
		//return 1;
	//}// конец вывода числа
	return 0; // что то пошло не так
}

//Процедура постановки в очередь вывода строки
//Попробовать сохранить адрес передаваемый в процедуру в массиве данных.
//Очистится ли строка передаваемая в процедуру??
void QueuingStr(char *MasOut){
	//добавить процедуру монитора очереди( нужно ли отправлять старт стоп и т.д)
	//Нужна ли здесь эта процедура?
	QueueProc[PoinProc++] = TrMasByte; //Запись процедуры в очередь
	QueueProc[PoinProc] = 0xFF;        //Признак конца очереди
	//Запись адреса массива символов в массив данных
	DataQueue[PoinQue++] =(char)((int)MasOut >> 8); //Запись старших байт адреса
	DataQueue[PoinQue++] =(char)MasOut; // запись младших байт
}
//Процедура постановки в очередь вывода одного символа
void QueuingSym(char ChaQ){
	QueueProc[PoinProc++]=PrintChar; // Вывод символа
	QueueProc[PoinProc] = 0xFF;        //Признак конца очереди
	DataQueue[PoinQue++]=ChaQ ;      // Сохранение кода символа в массиве данных процедур
}

//Процедура постановки в очередь вывода позиционирования строки
void QueuingLine(char Nstr){
       QueueProc[PoinProc++]= SetLine; //Запись процедуры в очередь
	   QueueProc[PoinProc] = 0xFF;      
	   MasPosYk[CountMasWr++] = Nstr;    // начальная строка для записи
	   MasPosYk[CountMasWr++] = 7;       // Конечная строка может быть 7 вместо 0??
}

//Процедура постановки в очередь вывода позиционирования столбца
void QueuingColon(char Ncol){
	 QueueProc[PoinProc++]= SetColomn; // запись процедуры в очередь
	 QueueProc[PoinProc] = 0xFF;        //Признак конца очереди
	 MasPosYk[CountMasWr++] = Ncol;    // начальная строка для записи
	 MasPosYk[CountMasWr++] = 15;      // Конечная строка может быть 7 вместо 0??
}

//Процедура постановки в очередь отправки инициализационных байт дисплея
void  QueuingSSDInit(){
	QueueProc[PoinProc++]= SSDInit; // запись процедуры в очередь
	QueueProc[PoinProc] = 0xFF;     // признак конца очереди
}

//Процедура постановки в очередь очистки экрана
void QueuingCleanSSD(unsigned char CountSymb){
	QueueProc[PoinProc++]= CleanSSD; // Номер процедуры в очередь
	QueueProc[PoinProc]= 0xFF;		// признак конца очереди
	DataQueue[PoinQue++] = CountSymb; // количество очищаемых символов в массив данных
}

//Процедура постановки вывода байта из памяти программ
void QueuingOutPM(char *ProgMemor){
	QueueProc[PoinProc++]= OutPMem; // // Номер процедуры в очередь
	QueueProc[PoinProc]= 0xFF;		// признак конца очереди
	DataQueue[PoinQue++] =(char)((int)ProgMemor >> 8); //Запись старших байт адреса
	DataQueue[PoinQue++] =(char)ProgMemor; // запись младших байт
}

// Процедура стартовой настройки модуля TWI для работы с экраном SSD1306
void StartTWISSD1306(){
//скорости I2C 400кГц SSD1306 должен поддерживать. 
//210kHz TWBR=30. TWPS=0;
	ConTWIPort(); //Настройка ног на вывод сигнала TWI
	ConfTime0(); // запускаю таймер на работу по переполнению таймера счетчика
	TWBR = 30; // 210kHz 
	QueuingSSDInit(); // постановка в очередь отправки байт инициализации
	QueuingCleanSSD(2); // Постановка в очередь полной очистки экрана //128 изменил на 2 для отладки
	__asm__ volatile("sei" ::: "memory"); //разрешение прерываний
}

//Вывод числа с заданной позиции или с другой.

// Здесь хранятся очереди задач на TWI и SPI (может потом добавлю другие)

