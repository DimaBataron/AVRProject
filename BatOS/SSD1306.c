/*
 * SSD1306.c
 *
 * Created: 15.01.2022 20:37:19
 *  Author: dima
 * Это что-то вроде драйвера на микросхему SSD1306
 Файл BatIO не должен переписыватся(является портируемым).
 Переписывается или подключается файл драйвера.
 */
#include "SSD1306.h" 
#include "BatTWI.h"       // Подключаю модуль работы с TWI(I2P)
#include "SetupBatOS.h"
#include "avr\pgmspace.h" //библиотека для работы с памятью программ

#ifdef SSD1306M
#define AdrSSD1306 0x78
/*
;SSD1306 ЭКРАНЧИК подключение.
;PC4=SDA=A4
;PC5=SCL=A5
;Подтягивающие резисторы?
*/
//Переменная видимая только в этом файле
static char CountTWISym=0; //Используется для хранения количества переданных байт символа
static char CountSet=0;
unsigned char CountMasPos=0; // Номер текущего элемента для чтения из массива 
static char CountMasInit=0; //Переменная содержит номер элемента массива инициализации
static unsigned char CountClean=0; //Очищаемый символ в текущий момент
static char Flag=0; // используется внутри процедуры для передачи байт инициализации
//позиционирования указателя.

extern unsigned char DataQueue[200];
extern unsigned char PoinQueRed;

extern unsigned char MasPosYk[40];  //Выделил 40 байт в оперативе для хранения
//данных позиционирования указателя
extern unsigned char CountMasWr; //Текущая позиция для записи в массив позиционирования

const char Num[][8] PROGMEM = { //Здесь байты символов.
	{0x1C,0x36,0x63,0x41,0x63,0x36,0x1C,0x00}, //0
	{0x00,0x10,0x31,0x7F,0x7F,0x01,0x00,0x00}, //1
	{0x00,0x63,0x67,0x4F,0x79,0x33,0x00,0x00}, //2
	{0x00,0x41,0x49,0x49,0x36,0x00,0x00,0x00}, //3
	{0x0C,0x1C,0x34,0x64,0x7F,0x04,0x00,0x00}, //4
	{0x00,0x73,0x71,0x5B,0x5F,0x4E,0x00,0x00}, //5
	{0x00,0x3E,0x7F,0x49,0x6F,0x66,0x00,0x00}, //6
	{0x00,0x60,0x67,0x4F,0x58,0x70,0x00,0x00}, //7
	{0x00,0x36,0x7F,0x49,0x49,0x7F,0x36,0x00}, //8
	{0x00,0x30,0x79,0x49,0x4B,0x7E,0x3E,0x00}  //9
	};
const char Symbol[][8] PROGMEM = { //Здесь байты символов
	{0x03,0x0E,0x3C,0x64,0x34,0x1E,0x07,0x00}, //а
	{0x41,0x7F,0x49,0x49,0x49,0x66,0x00,0x00}, //б
	{0x41,0x7F,0x49,0x49,0x49,0x36,0x00,0x00}, //в
	{0x41,0x7F,0x41,0x40,0x40,0x60,0x00,0x00}, //г
	{0,0,0,0,0,0,0,0},//д
	{0x41,0x7F,0x49,0x49,0x41,0x41,0x00,0x00}, //е
	{0,0,0,0,0,0,0,0},//ж
	{0,0,0,0,0,0,0,0},//з
	{0x7F,0x03,0x07,0x18,0x30,0x7F,0x00,0x00}, //и
	{0x7F,0x03,0x8E,0x98,0x30,0x7F,0x00,0x00}, //й
	{0x41,0x7F,0x1C,0x36,0x63,0x41,0x00,0x00}, //к
	{0x01,0x41,0x7E,0x40,0x40,0x7F,0x40,0x00}, //л
	{0x7F,0x40,0x20,0x10,0x20,0x40,0x7F,0x00},//м
	{0x41,0x7F,0x49,0x08,0x49,0x7F,0x41,0x00},//н
	{0x1C,0x22,0x41,0x41,0x41,0x22,0x1C,0x00},//о
	{0x41,0x7F,0x41,0x40,0x41,0x7F,0x41,0x00},//п
	{0x41,0x7F,0x49,0x48,0x48,0x30,0x00,0x00},//р
	{0x1C,0x22,0x43,0x81,0x81,0x22,0x00,0x00},//с
	{0x40,0x40,0x40,0x7F,0x40,0x40,0x40,0x00},//т
	{0x40,0x61,0x33,0x1E,0x0C,0x78,0x60,0x00},//y
	{0,0,0,0,0,0,0,0},//ф
	{0,0,0,0,0,0,0,0},//х
	{0x40,0x7E,0x02,0x02,0x02,0x7E,0x43,0x00},//ц
	{0x40,0x78,0x08,0x08,0x08,0x7F,0x41,0x00},//ч
	{0x7F,0x01,0x01,0x7F,0x01,0x01,0x7F,0x00},//ш
	{0,0,0,0,0,0,0,0},//щ
	{0,0,0,0,0,0,0,0},//ъ
	{0x7F,0x11,0x11,0x1F,0x00,0x7F,0x00,0x00},//ы
	{0x00,0x7F,0x1B,0x11,0x1B,0x0E,0x00,0x00},//ь
	{0,0,0,0,0,0,0,0},//э
	{0,0,0,0,0,0,0,0},//ю
	{0x00,0x01,0x71,0x4E,0x48,0x7F,0x41,0x00},//я	
	};

/*
;A0->A1; 22-12;
;A8,3f->A8,00  ->Кэф.Мулитиплексирования (стоило ли менять?)
;D3,00->D3,37   сдвиг строки от 0 до 63
;0x40      начальная строка
;0x81,0xFF значение контрасности
;0xA4 Вощобновить отображение с учетом содержания RAM
;0xD5,0x80 настройка делителя и частоты осциллятора
;0x8D,0x14 подключение повышающего преобразователя
;0x20,0x00 Режим горизонтальной адресации
;0xAF  включение дисплея
*/
const char InitSSD[] PROGMEM = {0xA8,0x00,0xD3,0x00,0x40,0xA1,0xC0,
	0xDA,0x12,0x81,0xFF,0xA4,0xA6,0xD5,0x80,0x8D,0x14,0x20,0x00,0xAF}; //20 байт
	
const char Point[] PROGMEM = {0x00,0x7F,0x7F,0x7F,0x3E,0x1C,0x08,0x00}; // байты указателя (стрелочки)

/*Процедура вывода символа
(ВЫЗЫВАЕТСЯ ПОВТОРНО)
//Получает код символа и начинает передачу.
//Добавить пробел и байты указателя стрелочки	
//Процедура выводит символ. На входе код символа.
//Возвращает 1 если еще не все передали
//			 0 все передали
*/
char PrintSym(unsigned char CharCode){ 
    char symbol=0; //в эту переменную положим адрес символа далее
	if (CountTWISym==8) //Символ передали
	{
		CountTWISym=0;
		return 0; 
	}
	else{ //получаем соответсвующий байт сивола код которого передали.
		if(CharCode==' '){ // пробел
			TrByte(0); // Выводим 8 раз пробел
		}
		else{
			if( CharCode < (unsigned char)0x3A){ //получили код цифры
			symbol = (CharCode-'0');
			TrByte(pgm_read_byte(&Num[symbol][CountTWISym])); // передается один байт символа
			}
			else{//тогда это код символа
			symbol = (CharCode-'а');
			TrByte(pgm_read_byte(&Symbol[symbol][CountTWISym]));//получаем код и начинаем отправку
			}
		}
		CountTWISym++;
		return 1;
	}
}

/*
Добавить процедуры установки строки, столбца
*/
/*
Процедура установки строки 
1.Формирует состояние повтарт
2.Отправляет управляющий байт 
3.Отправка байта начала 
4.Отправка байта конца.
5.Возвращает 1 если передача еще не окончена. 0 если все.
*/
//Перед вызовом записать в массив начальную и коненую строку от 0-7
//ДОПИСАТЬ ЧТО ДЕЛАЕТ ПОСЛЕ ТОГО КАК ПЕРЕДАЛА ДАННЫЕ
char SetLine(){
	 if(CountSet==0){
			TrByte(0x00);
		}
		else{
			if(CountSet==1){ //Управляющий байт передали
				//Первый байт команды
				TrByte(0x22);// возможно поменять только этот байт команды?
			}
			else {
				if(CountSet<4){//Передаем 2 байта начальной и конечной строки для вывода
					TrByte(MasPosYk[CountMasPos++]);					
				}
				else { //Все передали выходим
					CountSet=0;
					return 0;
				}
			}
		}
		CountSet++;
		return 1;
}

/*
Процедура установки столбца для вывода (символьный вывод, все строки по блокам 8 байт)
16 столбцов
Принимает на вход число от 0 до 16.
5.Возвращает 1 если передача еще не окончена. 0 если все.
*/
char SetColomn(){
	unsigned char OutColom;
	if(CountSet==0){
			TrByte(0x00);
		}
		else{ 
		if(CountSet==1){ //Управляющий байт передали
				//Первый байт команды
				TrByte(0x21);// ;Set Column Address
				}
			else { 
				if(CountSet<4){//Передаем 2 байта начальной и конечной строки для вывода
				OutColom = MasPosYk[CountMasPos++];
				OutColom = OutColom<<3; // Сдвиг на 3 разряда равносилен умножению на 8
				if(OutColom==120){ OutColom=127 ;}
				TrByte(OutColom);
				}
				else { //Все передали выходим
					CountSet=0;
					return 0;
				}
			}
		}
		CountSet++;
		return 1;	
}


//Стартовые подготовки перед запуском SSD1306(экранчик)
//Используется перед началом работы с экраном 
//Вызывается повторно из очереди задач. Отправляем байты инициализации
//И очищаем массив
//Возращает 1 если ициализация еще не окончена
char SSDInit(){
	if(CountMasInit==20)
		{
			CountMasInit=0 ; // здесь ошибка??
			return 0 ;
		}
	if(Flag == 0){ // формирую повстарт
		Flag++;
		SSisTWI(); // далее програма обработки очереди сама отправляет адрес
	}
	else{
		if(Flag == 1){ // отправляем управляющий байт 0x00. Говорит что далее будет команда
			Flag++;
			TrByte(0x00);
		}
		else {
			Flag = 0;
			TrByte(pgm_read_byte(&InitSSD[CountMasInit++])) ; //Отправка байт инициализации
			return 1 ;
		}
	}
	
}


//Процедура очистки экрана
//(Выводит пробелы 128 раз для очистки всего дисплея)
//CountSymb количество очищаемых символов
char CleanSSD(unsigned char CountSymb){
	char c;
	if(CountClean == 0){
		TrByte(0x40); // Передача команды которая указывает что дальше сплошной массив данных
		CountClean++;
		return 1;
	}
	if(CountClean<(CountSymb+1)){
		c = PrintSym(' ');
		if(c==1){
			return 1; //Передача не закончена, повторить
		}
		else CountClean++;
		return 1;
	}
	else {
		CountClean=0;
		return 0;    //Передача окончена.
	}
}


//Процедура передачи массива символов на экран
//Получает на вход адрес массива символов подлежащих выводу.
//Возвращает 1 если передача не закончена
char SSDTrMasByte(char *MasData){
	if(CountMasInit==0){ //Эта переменная равна 0 если управляющий байт еще не передали
		TrByte(0x40);// Управляющий байт указывает микросхеме SSD1306 что дальше сплошной массив байт.
		CountMasInit++;
		return 1; //передача еще не закончена
	}
	else{ //Управляющий байт передан
		if(CountMasInit==1){
			char CharCode;
			char c;
			CharCode= MasData[CountSet]; // получаем символ
			if(CharCode!=0){ // не конец массива
				c = PrintSym(CharCode); //Запускаем на вывод передачу массива байт символа
				if(c==0){//Передача этого символа закончена.
				CountSet++; // при следующем заходе возьмем следующий символ.
				return 1;
				}
			}
			else{ //Конец массива байт которые хотели передать
				CountSet = 0;
				CountMasInit = 0;
				return 0;
			}
			
		}
	}
}

// Процедура выводит один символ. Возвращает 1 если передача не закончена
char PrintChar(){
	if(CountMasInit==0){ //Эта переменная равна 0 если управляющий байт еще не передали
		TrByte(0x40);// Управляющий байт указывает микросхеме SSD1306 что дальше сплошной массив байт.
		CountMasInit++;
		return 1; //передача еще не закончена
	}
	else{ //Управляющий байт передан
		if(CountMasInit==1){
			char CharCode;
			char c;
			CharCode= DataQueue[PoinQueRed]; // получаем символ
			c = PrintSym(CharCode); //Запускаем на вывод передачу массива байт символа
			if(c==0){//Передача этого символа закончена.
					PoinQueRed++; // при следующем заходе возьмем следующий символ.
					CountMasInit = 0;
					return 0;
			}
		}
	}
}

//Вывод одного символа из памяти программ на экран (8байт)
//1 если передача не закончена
char OutPMem(){
	unsigned char *Adr;
	if(CountMasInit==8){
		Flag = 0;
		PoinQueRed++;
		PoinQueRed++;
		CountMasInit=0;
		return 0; // передача закончена
	}
	if(Flag==0){
		TrByte(0x40);// Управляющий байт указывает микросхеме SSD1306 что дальше сплошной массив байт.
		Flag++;
		return 1;
	}
	Adr = DataQueue[PoinQueRed] << 8;
	Adr =  ((int)Adr) | (((int)DataQueue[PoinQueRed+1]) & 0b0000000011111111);
	TrByte(pgm_read_byte(&Adr[CountMasInit++])) ; //Отправка байт инициализации
	return 1;
}

//Вывод на экран числа.
//1. Из памяти данных получаем число
//2. По этому числу выводим на экран символы из памяти программ
//1 если передача не закончена
char PrintNum(){
	unsigned char symbol;
	if(CountMasInit==0){ //Эта переменная равна 0 если управляющий байт еще не передали
		TrByte(0x40);// Управляющий байт указывает микросхеме SSD1306 что дальше сплошной массив байт.
		CountMasInit++;
		return 1; //передача еще не закончена
	}
	else{
		if(CountMasInit<6){
			if(CountTWISym<8){ //Продолжаем вывод символа на экран
					symbol = DataQueue[PoinQueRed+(5-CountMasInit)];
					TrByte(pgm_read_byte(&Num[symbol][CountTWISym])); // передается один байт символа
					CountTWISym++;
					return 1;
					}
			else{
				CountTWISym=0;
				CountMasInit++;
				return 1;
			}
		}
		else {
			CountMasInit=0;
			CountTWISym=0;
			PoinQueRed +=5;
			return 0 ;
		}
	}
}
#endif