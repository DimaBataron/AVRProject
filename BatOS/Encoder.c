/*
 * Encoder.c
 *
 * Created: 16.03.2022 2:27:12
 *  Author: dima
 Файл содержит процедуры для работы с энкодером
 */ 
#include "Encoder.h"
#include "BatTime.h"
#include <avr/io.h> //Описание всех регистров и портов контроллера
#include "SetupBatOS.h"
//#include <stdatomic.h> // определить переменную которая вызывается из прерывания
//#include "iom328p.h"


#ifdef BatTimeM
unsigned char Wait=0;  // используется для отслеживания состояния.
unsigned char sec = 0; // используется для отсчета времени.
#endif
//0 если было нажатие
//1 вправо поворот
//-1 влево поворот
//2 длительное нажатие
//4 не было изменений
volatile int ConditionEncoder = -1; // состояние изменения положения энкодера
//Процедура получает данные об изменении положения энкодера при вращении поставить на прерывание 

#ifdef EncoderM
void EncoderRet(){
	unsigned char c;
	c = PIND & (1<<PIND4);
	if(c==0){ //Повернули влево
		ConditionEncoder =-1;
	}
	else ConditionEncoder =1; //вправо
}
//процедура конфигурации камня Atmega328p для работы с энкодером
void GetSygEn(){
	/*
	;Энкодер
	;Int0=PD2=S1=D2
	;Int1=PD3=Key=D3 Энкодер сюда цепляем
	;PD4     =S2=D4
	*/
//Настройка ног на ввод с отключением подтягивающих резисторов
	DDRD  &= ~((1<<DDD2)|(1<<DDD3)|(1<<DDD4)); /// направление передачи данных
	PORTD &= ~((1<<PORTD2)|(1<<PORTD3)|(1<<PORTD4)); // Подтягивающий резистор   
	//PORTD |= (1<<PORTD4);
//Настройка обработки прерываний по спадающему фронту
	EICRA &= ~((1<<ISC10)|(1<<ISC00)|(1<<ISC11)|(1<<ISC01));		//сбрасываю биты
	EICRA |=  (1<<ISC11)|(1<<ISC01); //По спадающему фронту на выходе INT0 и INT1
//Разрешение прерываний 
	EIMSK = (1<<INT0)|(1<<INT1); 
}
#endif



//Процедура обрабатывает нажатие.
//По нажатию начинает отсчет. Если нажатие длительное 2. Если короткое 0.
//Маленькое если после маленького нажатия кнопка зажата начать длительный отсчет 
//на основании которого будет определено состояние
#ifdef BatTimeM
void EncoderPres(){
	unsigned char c=0;
	if(Wait==0){ // ожидаем нажатия
		Wait=1; // короткая выдержка
		sec = 5;
		ConfTime0();//включаю таймер
		return 0; 
	}
	if(Wait==1){ // Проверка на короткое нажатие
		if(sec>0){//Повторное нажатие(дребезг) ничего не делаем
			return 0;
		}
		else{ // выдержка была 	Int1=PD3=Key=D3(кнопка энкодера)
			c = PIND & (1<<PIND3);
			if(c==0){ // удерживается. Уточнить это длительное нажатие или завтыкал?
				Wait = 2;
				sec = 5; // может надо уменьшить
				return 0;
			}
			else{ // было короткое нажатие 
				Wait = 0; // отключаем отсчет по таймеру
				ConditionEncoder = 0; //указывает что короткое нажатие
				TimeOff(); // Отключаю таймер
				return 0 ;
			}
			
		}
	}
	if(Wait == 2){ 
		if(sec>0){//Повторное нажатие(дребезг) ничего не делаем
			return 0;
		}
		else{ //Большая  выдержка была 	Int1=PD3=Key=D3(кнопка энкодера)
			c = PIND & (1<<PIND3);
			if(c==0){ // Значит длительное нажатие
				Wait = 0;
				ConditionEncoder=2;
			}
			else {
				Wait = 0;
				ConditionEncoder=0; // короткое нажатие
			}
		}
	}
	TimeOff();
	return 0; // сюда вообще доходить не должно
}
#endif

