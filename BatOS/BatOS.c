/*
 *
 * Created: 15.01.2022 12:48:30
 *  Author: dima
 Обработчик прерываний для TWI режима ведущий передатчик
 */ 
#include "BatOS.h"
#include "BatIO.h"
#include "BatTime.h"
#include "SSD1306.h"
#include <avr/interrupt.h> // Подключаю обработчик прерывания

#define AdrSSD1306 0x78  //Адрес устройства

static char StatusTransit=0; //Переменная видимая только в этом файле расположены по мере частоты использвоания

//Внешняя переменная массив задач
extern char QueueProc[100]; // Очередь процедур BatIO.c
extern char PoinProcRed; // указатель на массив текущей процедуры для чтения BatIO.c
extern unsigned char DataQueue[200]; // данные процедур
extern unsigned char PoinQueRed; // Указатель на массив данных процедур для чтения
extern char PoinProc; //Номер массива процедур для записи
extern unsigned char PoinQue; //указатель на массив данных для записи
extern char CountMasPos; // Номер текущего элемента для чтения из массива 

extern char CountMasWr; //Текущая позиция для записи в массив позиционирования

/*
//Порядок передачи 
0. Передача не идет
1. адрес не передан
2. сигнал старт или повстарт сформирован
3. Данные отправлены но подтверждение не получено
4. Передача команд позиционирования
5. Данные переданы.
6. адрес на запись передан или байт передан
7. потеря приоритета при передачи
После отправки всегда отправляется адрес

*/
// Процедура обработки очереди задач и очистки очереди после передачи
void Processing(){
	unsigned char Proc,c;
	char *MasSymOUT=0; // Адрес массива символы которого нужно вывести
	Proc = QueueProc[PoinProcRed]; // Читаю задачу из очереди
	if(Proc!=0xFF){ // Если имеются задачи
		switch(StatusTransit){// посмотреть состояние выполнения	
			case 0:  //если передача не идет. 
				SSisTWI(); // Отправляем сигнал старт
			break;
			
			case 2: // был отправлен сигнал старт
				TrAdr(AdrSSD1306); //Отправляем адрес
			break;
			
			case 6: // Адрес передан или байт передан
			{
				switch(Proc){
					case 0: // Передача массива байт TrMasByte
					MasSymOUT = DataQueue[PoinQueRed] << 8;
					MasSymOUT =  ((int)MasSymOUT) | (((int)DataQueue[PoinQueRed+1]) & 0b0000000011111111); 
					
					c = SSDTrMasByte(MasSymOUT);  // передаю массив байт на которые указывает указатель MasSymOUT
					if(c == 0){ // передача завершена
						PoinQueRed++; //сдвигаю массив данных
						PoinQueRed++;
						PoinProcRed++; //сдвигаю указатель в массиве задач
						StatusTransit = 0; // данные переданы
						TWCR = (1<<TWINT);
					} //ПОСЛЕ ПЕРЕДАЧИ ОБНУЛЯЕТСЯ МАССИВ MasPosYk 0xFF почему??
					break;
					
					case 1: // установка строки SetLine
					c = SetLine();// сама формирует повстарт и передает адрес
					if(c == 0){
						PoinProcRed++; // сдвигаю указатель в массиве задач
						StatusTransit = 0; //Данные переданы
						TWCR = (1<<TWINT); // Сброс флага прерывания от TWI. Запуск только по таймеру.
					}
					break;
					
					case 2:  // установка столбца SetColomn
					c = SetColomn();
					if(c == 0){
						PoinProcRed++;
						StatusTransit = 0; // Данные переданы
						TWCR = (1<<TWINT); // Сброс флага прерывания от TWI. Запуск только по таймеру.
					}
					break;
					// Дописать вывод одного символа.
					case 3: //вывод одного символа PrintChar
					c = PrintChar();
					if(c == 0){
						PoinProcRed++;
						StatusTransit = 0; // Данные переданы
						TWCR = (1<<TWINT); // Сброс флага прерывания от TWI. Запуск только по таймеру.
					}
					break;
					case 4: //Отправка массива инициализации
					c = SSDInit(); 
					if(c == 0){ // еще не передалось а переходит сюда и выполнятеся код раньше времени
						PoinProcRed++;
						StatusTransit = 0;
						TWCR = (1<<TWINT);
					}
					break;
					case 5: //Процедура очистки дисплея
					c = CleanSSD(DataQueue[PoinQueRed]); // в массиве количество очищаемых символов
					if(c==0){ // передача закончена
						PoinProcRed++;
						PoinQueRed++;
						StatusTransit = 0;
						TWCR = (1<<TWINT);
					}
					break;
					case 6: //продедура вывода одного символа из памяти программ
					c = OutPMem();
					if(c==0){
						PoinProcRed++;
						StatusTransit = 0;
						TWCR = (1<<TWINT);
					}
					break;
				}
			}
					
		}
	}
	else{ // сюда если очередь пуста.
		PoinProcRed = 0; // указатель для чтения очери обнуляем.
		QueueProc[PoinProcRed]=0xFF; // записываем что нет в очереди задач элементов
		StatusTransit = 0;
		PoinQueRed = 0; // номер читаемего элемента массива данных
		CountMasWr = 0; // Обнуляем номер элемента массива записи позиционирования каретки.
		PoinProc = 0; // Элемента массива для записи задач
		PoinQue=0;    // Элемент массива для записи данных
		CountMasPos = 0; // Элемент массива позиционирования для чтения
	}
}
/*
//Разрешение прерываний
void sei(){
		__asm__ volatile("sei" ::: "memory");
}
*/
//Запрещение прерываний
/*
void cli(){
	__asm__ volatile("cli" ::: "memory");
}
*/



// Прерывания
ISR(TWI_vect){ // Прерывание от модуля TWI (Это для режима ведущий передатчик)
	//Нужно ли сохранять статус регистр и востанавливать потом? Посмотереть как это выполняется в 
	//Дизасемблером
	switch(TWSR){
		case 0x08 :
		StatusTransit = 2; // был передан сигнал старт. Устанавливаю статус что передали старт
		Processing();
		break;
		
		case 0x10 : // повстарт тоже что и старт. После него передается адрес
		StatusTransit = 2;
		Processing();
		break;
		
		case 0x18 :
		StatusTransit = 6; // Устанавливаю флаг что адрес + бит (W) записи переданы.
		Processing();
		break;
		
		case 0x28 : // передан пакет данных и принято подтверждение
		StatusTransit = 6; //5 здесь изменил после передачи данных
		Processing();
		break;
		
		case 0x20 : // передан пакет а подтверждение не принято
		StatusTransit = 1 ;				// Что делаем в таком случае?
		Processing();					// 1. Можно посчитать повторные отправки адреса
		break;							// 2. Можно Отправить сигнал стоп и старт снова или повстарт или не обращать внимания
		
		case  0x30 : // передан пакет данных а подтверждение не принято
		StatusTransit = 3;
		Processing();
		break;
		
		case 0x38 : // потеря приоритета при передачи ЧТО БУДЕМ ДЕЛАТЬ?
		StatusTransit = 7;
		Processing();
		break;
	}
}
//По прерыванию от переполнения таймера счетчика запускаем обработчик очереди
ISR(TIMER0_OVF_vect){
	if(StatusTransit ==0){
		if(PoinProc!=0) { // если есть задачи и очередь задач не очищена запуск обработки очереди
			Processing(); // если передача не идет начать ее. Может увеличить частоту запуска?
		}
	}
	// else // проверка очереди задач если пустая очистить очереди задач и сбросить указатели в начало
}
