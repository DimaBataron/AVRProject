/*
 * DefFile4.inc
 *
 *  Created: 12.07.2021 20:17:43
 *   Author: dima
 */ 
 ;================Глобальные=======================================
 ;В этих двух регистрах буду хранить число которое накрутили энкодером
 ;Используется для последующего вычисления числа передаваемого на AD9833
 ;А также получения кодов числа.
 .def NumFrH = r14 ;<<<<<-------Эти два регистра не трогать нигде в программе
 .def NumFrL = r15 ; (Число) обозначено на блок схеме.
 ;При повороте энкодера изменять эти значения
;Эти регистры использую для хранения значения из которого 
;Получаю коды символов
.def CountEncoder = r19  ;Этот регистр также трогать нельзя <<<<<-------
.def Tmp2 = r21			; Этот регист сохранять в стеке(трогать нельзя) <<<---------


;=====================Локальные=====================================
;Используються в вызывающей процедуре(Мое определение). 
;После выхода из вызывающей процедуры  можно затирать

;r9 r10 r11 r12 Числа r9 старшее
 .def Num1 = r9 ;Здесь коды символов числа
 .def Num2 = r10 ;Используются для вывода на экран
 .def Num3 = r11
 .def Num4 = r12
 .def Num5 = r13
.def FisByte = r22		;байты передаваемые в массив данных
.def SecByte = r23 	    ;2
.def ThirByte= r24	    ;3
.def FourtByte=r25	    ;4


 ;==================Временные==========================================
 ;Используются только в текущей процедуре
.def Mn1   = r1 ;множимое
.def Mn2   = r2
;дальше используются 
.def VremenPrH = r3 ;Запоминаю значение Времен 1 полученное на предыдущей интерации
.def VremenPrL = r4 ;Получения кода символа

.def TmpAsH =	 r16 ;старший Времен1 на блок схеме
;.def TmpAsL =	 r17   ;Конфликт
.def Quant=		 r17	; сколько слов кладем в память 	
.def CE  =		 r18	;Иногда использую для нажатий используется в нескольких процедурах;тут храню временное значение для вычислений
.def OSRG =		 r20	;назначить регистру символическое имя
.def FsMM		  = r26  ; эти 4 регистра трогать нельзя  <<<<-----------------------
.def FsML		  = r27  ; В стеке сохранять только в блоке где запрещены 
.def FsLM         = r28	 ; прерывания
.def FsLL         = r29	 ;Использования для вычисления значения 
;которое будет записано в генератор частоты
;Множитель
.def Mng1      = r5  
.def Mng2      = r6
.def Mng3      = r7
.def Mng4      = r8


;=============================================================================
;Это номера соответствуют порядку задач в массиве процедур. 
.equ TS_WordTr       = 0	;Просто нумерация. Не более того
.equ TS_TwoWordTr    = 1    ;Зато теперь можно смело отправлять в очередь 
.equ TS_StartInit    = 2    ;Процедура стартовой инициализации
.equ TS_TrData       = 3	;Процедура передачи символов на экран
.equ TS_Clean		 = 4    ;Процедура очистки дисплея
.equ TS_PosYkP       = 5	;Процедура позиционирования строки
.equ TS_PosYkCol	 = 6	;Процедура позиционирования столбца
.equ TS_TrPointSym   = 7	;Процедура вывода одного символа на экран(указателя)
.equ TS_StopSig      = 8    ;Процедура отправки сигнала стоп
.equ TS_StartSig     = 9    ;Процедура отправки сигнала старт
.equ TS_EndQue		 =10	;Процедура проверки конца очереди
.equ TS_TrDataReg    =11	;Процедура вывода цифры из регистров r9-r12 r9 старший




;Данные SPI части
.DSEG
TaskQueue:
		.org TaskQueue+200 ; Выделяем в ОЗУ место для очереди размеров в 200 байт.
MasByte: ;(Начало массива)
		.org MasByte+600     ; Выделяем 600 байт для данных в ОЗУ под массив данных
CurrentByteL:  .db  1   ;Адрес текущего байта данных для записи
CurrentByteH:  .db  1  
;Дальше пишем наши данные в ОЗУ  
ReadDatL:    .db 1 ;адрес текущего передаваемого байта(чтения) данных из массива передачи
ReadDatH:	 .db 1 ;
;
;Данные выбраного режима
DcomH:		.db 1
;
TrDataCal:	.db 1 ;Здесь храню количество переданных символов из регистра 

;===========================================================================================
;Данные TWI части для вывода на экран
;StartInit
InitCount:		.byte 1	;счетчик состояния инициализации
LenMasInit:		.byte 1	;длинна массива инициализации
NumWhileInit :	.byte 1	;количество повторений цикла передачи конфиг битов
ZInitLow:		.byte 1 ;в этой области r30. Сохраняем сюда младший адрес массива инициализации при старте мк.
ZInitHi:		.byte 1 ;в этой области r31. Cохраняю сюда старший адрес массива при инициализации.
AdrSSD:			.byte 1	;адрес ведомого

;TrData				данные
;TrDataCountB		флаг того что нужно передать управляющий байт (При инициализации передачи массива символов)
;TrDataCount		количество байт одного символа которые уже передали
;TrDatF				При первом входе беру адреса массива для вывода из данных процедуры.
;3 ячейки обнуляю при стартовой инициализации программы
TrDatLow:     .byte 1  ;r30. Сохраняем сюда младший адрес массива символов которые выводятся
TrDatHi:      .byte 1  ;в этой области r31. Cтарший байт адреса массива символов
TrDataCount:  .byte 1  ;количество байт одного символа которые уже передали
TrDataCountB: .byte 1  ;флаг того что нужно передать управляющий байт (При инициализации передачи массива символов)
TrSymByteL:   .byte 1  ;указатель на массив передаваемого байта одного символа
TrSymByteH:   .byte 1  ;указатель на массив 
TrDatF:       .byte 1 

;Clean очистка дисплея
;r18 r19 r20
;CleanNow:              очищаемый в данный момент символ
;CleanSym:              количество символов которые надо очистить
;CleanWhile:  			очищаемый байт в текущий момент
;CleanByte:				байт которым заполняем все пространство.
;CleanFlag:				флаг указывающий о том что уже входили в процедуру и что передавать байт x40 не надо. Не забыть сбросить при выходе!!!
CleanNow:		.byte 1
CleanSym:       .byte 1
CleanWhile:     .byte 1
CleanByte:		.byte 1
CleanFlag:		.byte 1

;PosYkP	и PosYkCol			процедура позиционирования строки
;NumWhilePos		количество переданных байт позиционирования
;CountPosYk	        счетчик состояния позиционирования.
;SelectPosYk		вложенный для определения байта.
NumWhilePos:    .byte 1
CountPosYk:		.byte 1
SelectPosYk:	.byte 1 

PosMemStr:		.byte 1	;строка
PosMemStrEnd:	.byte 1 ;конечная строка используемая при выводе
PosMemCol:		.byte 1 ;столбец
PosMemColEnd:	.byte 1 ;конечный столбец вывода.
